/* esm.sh - esbuild bundle(openai@4.67.2/lib/AssistantStream) denonext production */
import*as k from"/v135/openai@4.67.2/denonext/core.js";import{Stream as F}from"/v135/openai@4.67.2/denonext/streaming.js";import{APIUserAbortError as y,OpenAIError as I}from"/v135/openai@4.67.2/denonext/error.js";import{EventStream as $}from"/v135/openai@4.67.2/denonext/lib/EventStream.js";var n=function(o,e,a,r){if(a==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?o!==e||!r:!e.has(o))throw new TypeError("Cannot read private member from an object whose class did not declare it");return a==="m"?r:a==="a"?r.call(o):r?r.value:e.get(o)},c=function(o,e,a,r,t){if(r==="m")throw new TypeError("Private method is not writable");if(r==="a"&&!t)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?o!==e||!t:!e.has(o))throw new TypeError("Cannot write private member to an object whose class did not declare it");return r==="a"?t.call(o,a):t?t.value=a:e.set(o,a),a},d,v,f,A,u,p,w,_,R,l,x,E,g,b,S,M,D,T,W,j,P,O,C=class o extends ${constructor(){super(...arguments),d.add(this),v.set(this,[]),f.set(this,{}),A.set(this,{}),u.set(this,void 0),p.set(this,void 0),w.set(this,void 0),_.set(this,void 0),R.set(this,void 0),l.set(this,void 0),x.set(this,void 0),E.set(this,void 0),g.set(this,void 0)}[(v=new WeakMap,f=new WeakMap,A=new WeakMap,u=new WeakMap,p=new WeakMap,w=new WeakMap,_=new WeakMap,R=new WeakMap,l=new WeakMap,x=new WeakMap,E=new WeakMap,g=new WeakMap,d=new WeakSet,Symbol.asyncIterator)](){let e=[],a=[],r=!1;return this.on("event",t=>{let s=a.shift();s?s.resolve(t):e.push(t)}),this.on("end",()=>{r=!0;for(let t of a)t.resolve(void 0);a.length=0}),this.on("abort",t=>{r=!0;for(let s of a)s.reject(t);a.length=0}),this.on("error",t=>{r=!0;for(let s of a)s.reject(t);a.length=0}),{next:async()=>e.length?{value:e.shift(),done:!1}:r?{value:void 0,done:!0}:new Promise((s,i)=>a.push({resolve:s,reject:i})).then(s=>s?{value:s,done:!1}:{value:void 0,done:!0}),return:async()=>(this.abort(),{value:void 0,done:!0})}}static fromReadableStream(e){let a=new o;return a._run(()=>a._fromReadableStream(e)),a}async _fromReadableStream(e,a){let r=a?.signal;r&&(r.aborted&&this.controller.abort(),r.addEventListener("abort",()=>this.controller.abort())),this._connected();let t=F.fromReadableStream(e,this.controller);for await(let s of t)n(this,d,"m",b).call(this,s);if(t.controller.signal?.aborted)throw new y;return this._addRun(n(this,d,"m",S).call(this))}toReadableStream(){return new F(this[Symbol.asyncIterator].bind(this),this.controller).toReadableStream()}static createToolAssistantStream(e,a,r,t,s){let i=new o;return i._run(()=>i._runToolAssistantStream(e,a,r,t,{...s,headers:{...s?.headers,"X-Stainless-Helper-Method":"stream"}})),i}async _createToolAssistantStream(e,a,r,t,s){let i=s?.signal;i&&(i.aborted&&this.controller.abort(),i.addEventListener("abort",()=>this.controller.abort()));let h={...t,stream:!0},m=await e.submitToolOutputs(a,r,h,{...s,signal:this.controller.signal});this._connected();for await(let q of m)n(this,d,"m",b).call(this,q);if(m.controller.signal?.aborted)throw new y;return this._addRun(n(this,d,"m",S).call(this))}static createThreadAssistantStream(e,a,r){let t=new o;return t._run(()=>t._threadAssistantStream(e,a,{...r,headers:{...r?.headers,"X-Stainless-Helper-Method":"stream"}})),t}static createAssistantStream(e,a,r,t){let s=new o;return s._run(()=>s._runAssistantStream(e,a,r,{...t,headers:{...t?.headers,"X-Stainless-Helper-Method":"stream"}})),s}currentEvent(){return n(this,x,"f")}currentRun(){return n(this,E,"f")}currentMessageSnapshot(){return n(this,u,"f")}currentRunStepSnapshot(){return n(this,g,"f")}async finalRunSteps(){return await this.done(),Object.values(n(this,f,"f"))}async finalMessages(){return await this.done(),Object.values(n(this,A,"f"))}async finalRun(){if(await this.done(),!n(this,p,"f"))throw Error("Final run was not received.");return n(this,p,"f")}async _createThreadAssistantStream(e,a,r){let t=r?.signal;t&&(t.aborted&&this.controller.abort(),t.addEventListener("abort",()=>this.controller.abort()));let s={...a,stream:!0},i=await e.createAndRun(s,{...r,signal:this.controller.signal});this._connected();for await(let h of i)n(this,d,"m",b).call(this,h);if(i.controller.signal?.aborted)throw new y;return this._addRun(n(this,d,"m",S).call(this))}async _createAssistantStream(e,a,r,t){let s=t?.signal;s&&(s.aborted&&this.controller.abort(),s.addEventListener("abort",()=>this.controller.abort()));let i={...r,stream:!0},h=await e.create(a,i,{...t,signal:this.controller.signal});this._connected();for await(let m of h)n(this,d,"m",b).call(this,m);if(h.controller.signal?.aborted)throw new y;return this._addRun(n(this,d,"m",S).call(this))}static accumulateDelta(e,a){for(let[r,t]of Object.entries(a)){if(!e.hasOwnProperty(r)){e[r]=t;continue}let s=e[r];if(s==null){e[r]=t;continue}if(r==="index"||r==="type"){e[r]=t;continue}if(typeof s=="string"&&typeof t=="string")s+=t;else if(typeof s=="number"&&typeof t=="number")s+=t;else if(k.isObj(s)&&k.isObj(t))s=this.accumulateDelta(s,t);else if(Array.isArray(s)&&Array.isArray(t)){if(s.every(i=>typeof i=="string"||typeof i=="number")){s.push(...t);continue}for(let i of t){if(!k.isObj(i))throw new Error(`Expected array delta entry to be an object but got: ${i}`);let h=i.index;if(h==null)throw console.error(i),new Error("Expected array delta entry to have an `index` property");if(typeof h!="number")throw new Error(`Expected array delta entry \`index\` property to be a number but got ${h}`);let m=s[h];m==null?s.push(i):s[h]=this.accumulateDelta(m,i)}continue}else throw Error(`Unhandled record type: ${r}, deltaValue: ${t}, accValue: ${s}`);e[r]=s}return e}_addRun(e){return e}async _threadAssistantStream(e,a,r){return await this._createThreadAssistantStream(a,e,r)}async _runAssistantStream(e,a,r,t){return await this._createAssistantStream(a,e,r,t)}async _runToolAssistantStream(e,a,r,t,s){return await this._createToolAssistantStream(r,e,a,t,s)}};b=function(e){if(!this.ended)switch(c(this,x,e,"f"),n(this,d,"m",T).call(this,e),e.event){case"thread.created":break;case"thread.run.created":case"thread.run.queued":case"thread.run.in_progress":case"thread.run.requires_action":case"thread.run.completed":case"thread.run.failed":case"thread.run.cancelling":case"thread.run.cancelled":case"thread.run.expired":n(this,d,"m",O).call(this,e);break;case"thread.run.step.created":case"thread.run.step.in_progress":case"thread.run.step.delta":case"thread.run.step.completed":case"thread.run.step.failed":case"thread.run.step.cancelled":case"thread.run.step.expired":n(this,d,"m",D).call(this,e);break;case"thread.message.created":case"thread.message.in_progress":case"thread.message.delta":case"thread.message.completed":case"thread.message.incomplete":n(this,d,"m",M).call(this,e);break;case"error":throw new Error("Encountered an error event in event processing - errors should be processed earlier")}},S=function(){if(this.ended)throw new I("stream has ended, this shouldn't happen");if(!n(this,p,"f"))throw Error("Final run has not been received");return n(this,p,"f")},M=function(e){let[a,r]=n(this,d,"m",j).call(this,e,n(this,u,"f"));c(this,u,a,"f"),n(this,A,"f")[a.id]=a;for(let t of r){let s=a.content[t.index];s?.type=="text"&&this._emit("textCreated",s.text)}switch(e.event){case"thread.message.created":this._emit("messageCreated",e.data);break;case"thread.message.in_progress":break;case"thread.message.delta":if(this._emit("messageDelta",e.data.delta,a),e.data.delta.content)for(let t of e.data.delta.content){if(t.type=="text"&&t.text){let s=t.text,i=a.content[t.index];if(i&&i.type=="text")this._emit("textDelta",s,i.text);else throw Error("The snapshot associated with this text delta is not text or missing")}if(t.index!=n(this,w,"f")){if(n(this,_,"f"))switch(n(this,_,"f").type){case"text":this._emit("textDone",n(this,_,"f").text,n(this,u,"f"));break;case"image_file":this._emit("imageFileDone",n(this,_,"f").image_file,n(this,u,"f"));break}c(this,w,t.index,"f")}c(this,_,a.content[t.index],"f")}break;case"thread.message.completed":case"thread.message.incomplete":if(n(this,w,"f")!==void 0){let t=e.data.content[n(this,w,"f")];if(t)switch(t.type){case"image_file":this._emit("imageFileDone",t.image_file,n(this,u,"f"));break;case"text":this._emit("textDone",t.text,n(this,u,"f"));break}}n(this,u,"f")&&this._emit("messageDone",e.data),c(this,u,void 0,"f")}},D=function(e){let a=n(this,d,"m",W).call(this,e);switch(c(this,g,a,"f"),e.event){case"thread.run.step.created":this._emit("runStepCreated",e.data);break;case"thread.run.step.delta":let r=e.data.delta;if(r.step_details&&r.step_details.type=="tool_calls"&&r.step_details.tool_calls&&a.step_details.type=="tool_calls")for(let s of r.step_details.tool_calls)s.index==n(this,R,"f")?this._emit("toolCallDelta",s,a.step_details.tool_calls[s.index]):(n(this,l,"f")&&this._emit("toolCallDone",n(this,l,"f")),c(this,R,s.index,"f"),c(this,l,a.step_details.tool_calls[s.index],"f"),n(this,l,"f")&&this._emit("toolCallCreated",n(this,l,"f")));this._emit("runStepDelta",e.data.delta,a);break;case"thread.run.step.completed":case"thread.run.step.failed":case"thread.run.step.cancelled":case"thread.run.step.expired":c(this,g,void 0,"f"),e.data.step_details.type=="tool_calls"&&n(this,l,"f")&&(this._emit("toolCallDone",n(this,l,"f")),c(this,l,void 0,"f")),this._emit("runStepDone",e.data,a);break;case"thread.run.step.in_progress":break}},T=function(e){n(this,v,"f").push(e),this._emit("event",e)},W=function(e){switch(e.event){case"thread.run.step.created":return n(this,f,"f")[e.data.id]=e.data,e.data;case"thread.run.step.delta":let a=n(this,f,"f")[e.data.id];if(!a)throw Error("Received a RunStepDelta before creation of a snapshot");let r=e.data;if(r.delta){let t=C.accumulateDelta(a,r.delta);n(this,f,"f")[e.data.id]=t}return n(this,f,"f")[e.data.id];case"thread.run.step.completed":case"thread.run.step.failed":case"thread.run.step.cancelled":case"thread.run.step.expired":case"thread.run.step.in_progress":n(this,f,"f")[e.data.id]=e.data;break}if(n(this,f,"f")[e.data.id])return n(this,f,"f")[e.data.id];throw new Error("No snapshot available")},j=function(e,a){let r=[];switch(e.event){case"thread.message.created":return[e.data,r];case"thread.message.delta":if(!a)throw Error("Received a delta with no existing snapshot (there should be one from message creation)");let t=e.data;if(t.delta.content)for(let s of t.delta.content)if(s.index in a.content){let i=a.content[s.index];a.content[s.index]=n(this,d,"m",P).call(this,s,i)}else a.content[s.index]=s,r.push(s);return[a,r];case"thread.message.in_progress":case"thread.message.completed":case"thread.message.incomplete":if(a)return[a,r];throw Error("Received thread message event with no existing snapshot")}throw Error("Tried to accumulate a non-message event")},P=function(e,a){return C.accumulateDelta(a,e)},O=function(e){switch(c(this,E,e.data,"f"),e.event){case"thread.run.created":break;case"thread.run.queued":break;case"thread.run.in_progress":break;case"thread.run.requires_action":case"thread.run.cancelled":case"thread.run.failed":case"thread.run.completed":case"thread.run.expired":c(this,p,e.data,"f"),n(this,l,"f")&&(this._emit("toolCallDone",n(this,l,"f")),c(this,l,void 0,"f"));break;case"thread.run.cancelling":break}};export{C as AssistantStream};
//# sourceMappingURL=AssistantStream.js.map